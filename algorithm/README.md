# 经典算法
## 排序算法
    最常用的一些排序算法算法：冒泡排序、插入排序、选择排序、快速排序、归并排序、基数排序、计数排序、桶排序。</br>
    按时间复杂度可以分为三类：</br>
      排序算法                时间复杂度         是否基于比较
      冒泡、插入、选择           O(n2)               Y
      快排、归并                O(nlogn)            Y
      桶、计数基数               O(n)                N
 
分析排序算法需从三方面考虑：</br>

1.排序算法的执行效率
    
    1.最好情况、最坏情况、平均情况时间复杂度
        在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，
        此外还要说出最好、最坏时间复杂度对应的原始数据是什么样的。之所以要区分这三种时间复杂度原因有二：
        1.有些排序算法需要区分，为了好对比
        2.对于要排序的数据，有的接近有序，有的完全无序，有序度不同的数据，对排序的执行时间是有影响的，
        我们要知道排序算法在不同数据下的性能表现。
    2.时间复杂度的系数、常数、低阶
        时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但在实际的软件开发中，
        我们排序的数据可能是10个、100个或者1000个这样的小规模数据，所以在对同一阶时间复杂的排序算法的性能对比的时候，
        就要把这些系数、常数、低阶也考虑进来。
    3.比较次数和交换（移动）次数
        基于比较的排序算法的执行过程中会涉及到两种操作，一种是元素比较大小，一种是元素移动或交换，所以我们在分析排序算法的
        执行效率的时候，应该把比较次数或交换（移动）次数也考虑进去。

2.排序算法的内存消耗

    算法的内存消耗可以通过空间复杂度来衡量，同样排序算法也不例外，此外针对排序算法还有一个概念叫原地排序（Sorted in place）。
    原地排序算法就是特指空间复杂度是O（1）的排序算法。
    
3.排序算法的稳定性
    
    仅用执行效率和内存消耗来衡量排序算法的还坏是不够的，针对排序算法还有一个重要的衡量指标，叫稳定性。意思是说待排序的序列中
    存在值相等的元素，经过排序之后，相等元素原有的前后顺序不变。

冒泡、插入、选择

    时间复杂度都是O（n2），适合小规模数据
    
归并、快排
    
    归并排序和快速排序的算法时间复杂度都是O(nlogn),适合大规模数据，较上三个算法更常用。
    这两种排序算法都运用了分治思想。分治，顾名思义就是分而治之，将一个大的问题分解成小的子问题，小问题解决了，大问题就解决了。
    分治思想与递归思想类似，其实分治算法就是通过递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，二者并不冲突。
归并排序原理：
    
    其核心思想是把要排序的数组从中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合并，这样整个数组就排序好了。
如图：
![image](https://github.com/chysh/data_struct/blob/master/images/guibing_20190926113654.jpg)

    归并排序用分之思想，可以用递归来实现。递归代码实现的技巧是：分析出递推公式，找到终止条件，最后将递推公式翻译成代码。
        递推公式：
        merge_sort(p…r) = merge(merge_sort(p…q),merge_sort(q+1…r）)
        终止条件：
        q >= r 不用再继续分解
    merge_sort(p…r)表示给下标从p到r的数组排序，将这个排序问题转换成两个子问题，merge_sort(p…q)和merge_sort(q+1…r），
    q是p和r的中间位置，也就是（p+r）/2，当下标从p到q和q+1到r这两个子数组排好序之后，再将这两个排好序的子数组合并在一起，
    这样下标p到r的数组就排好序了。
    代码实现见程序[merge_sort.c].
快速排序原理：

    其核心思想是把下标为p到r的一组数据排序，选择p到r之间的任意一个数据作为pivot（分去点）。然后遍历p到r的数据，
    将小于pivot数放在左边，大于pivot的数据放在右边，pivot放在中间，经过这一步骤之后，p到r之间的数据就被分成了三部分，
    其中前面p到q-1是小于pivot的部分，中间是pivot，后面的q+1到r的部分大于pivot。
![image](https://github.com/chysh/data_struct/blob/master/images/quick_sort_1.jpg)
    
    根据分治、递归的处理思想，可以用递归排序下标从p到q-1和q+1到r之间的数据，直到区间缩小为1，则说明所有的数据都有序了。
        递推公式：
        quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1…r)
        终止条件：
        p >= r
分区过程如下可以实现原地排序：
![image](https://github.com/chysh/data_struct/blob/master/images/pivot.jpg)
    
    代码实现见程序[quick_sort.c]

    
    
    
    
    
