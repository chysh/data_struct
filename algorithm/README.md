# 经典算法
## 排序算法
    最常用的一些排序算法算法：冒泡排序、插入排序、选择排序、快速排序、归并排序、基数排序、计数排序、桶排序。</br>
    按时间复杂度可以分为三类：</br>
      排序算法                时间复杂度         是否基于比较
      冒泡、插入、选择           O(n2)               Y
      快排、归并                O(nlogn)            Y
      桶、计数基数               O(n)                N
 
分析排序算法需从三方面考虑：</br>

1.排序算法的执行效率
    
    1.最好情况、最坏情况、平均情况时间复杂度
        在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度，
        此外还要说出最好、最坏时间复杂度对应的原始数据是什么样的。之所以要区分这三种时间复杂度原因有二：
        1.有些排序算法需要区分，为了好对比
        2.对于要排序的数据，有的接近有序，有的完全无序，有序度不同的数据，对排序的执行时间是有影响的，
        我们要知道排序算法在不同数据下的性能表现。
    2.时间复杂度的系数、常数、低阶
        时间复杂度反应的是数据规模n很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但在实际的软件开发中，
        我们排序的数据可能是10个、100个或者1000个这样的小规模数据，所以在对同一阶时间复杂的排序算法的性能对比的时候，
        就要把这些系数、常数、低阶也考虑进来。
    3.比较次数和交换（移动）次数
        基于比较的排序算法的执行过程中会涉及到两种操作，一种是元素比较大小，一种是元素移动或交换，所以我们在分析排序算法的
        执行效率的时候，应该把比较次数或交换（移动）次数也考虑进去。

2.排序算法的内存消耗

    算法的内存消耗可以通过空间复杂度来衡量，同样排序算法也不例外，此外针对排序算法还有一个概念叫原地排序（Sorted in place）。
    原地排序算法就是特指空间复杂度是O（1）的排序算法。
    
3.排序算法的稳定性
    
    仅用执行效率和内存消耗来衡量排序算法的还坏是不够的，针对排序算法还有一个重要的衡量指标，叫稳定性。意思是说待排序的序列中
    存在值相等的元素，经过排序之后，相等元素原有的前后顺序不变。

冒泡、插入、选择

    时间复杂度都是O（n2），适合小规模数据
    
归并、快排
    
    归并排序和快速排序的算法时间复杂度都是O(nlogn),适合大规模数据，较上三个算法更常用。
    这两种排序算法都运用了分治思想。
    
    
    
