数据结构与算法的学习
==
1.关于队列

      基于数组的队列，链表的队列，循环队列。一些高级的队列结构如阻塞队列，并发队列其底层还是队列的基本结构，
      只不过是在之上附加了其他功能。阻塞队列就是入队、出队操作可以阻塞。当队列为空时从对头取数时会阻塞，
      直到队列中有数据之后才返回；当队列为满时的插入操作就会阻塞，直到队列中有空闲位置时插入数据之后在返回。
      并发队列就是队列的操作多线程安全，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

2.散列表/哈希表（Hash Table）
      
      散列思想：
      散列表用的是数组支持下标随机访问的数据特性，所以散列表其实就是一种数组的扩展，有数组演化而来，
      可以说，没有数组就没有散列表。
![image](https://github.com/chysh/data_struct/blob/master/images/hash.jpg)
      
      散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，
      然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，
      从对应的数组下标的位置取数据。
      
      散列函数：顾名思义是一个函数，记作 hash(key),key代表元素的键值，hash(key)的值就是经过散列函数计算得到的散列值。
      散列函数设计的基本要求：
            1.散列函数计算得到的散列值是非负整数。
            2.如果key1 == key2，那么hash(key1) == hash(key2).
            3.如果key1 != key2，那么hash(key1) != hash(key2).
            其中第三点，在真实的环境中，要找到一个不同的key得到不同的散列值的散列函数，几乎是不可能的，即使是业界著名的
            MD5，SHA，CRC等哈希算法也无法避免这种散列冲突，而且数组的空间有限，也会加大这种散列冲突的概率。
            
      散列冲突：
         再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，
         开放寻址法（open addressing）和链表法（chaining）。
         1.开放寻址法
            开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？
            一个比较简单的探测方法，线性探测（Linear Probing）： 当我们往散列表中插入数据时，如果某个数据经过散列函数散列
            之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
            如下图（黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。）
            


         2.链表法
            
 
