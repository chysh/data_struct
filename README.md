数据结构与算法的学习
==
1.关于队列

      基于数组的队列，链表的队列，循环队列。一些高级的队列结构如阻塞队列，并发队列其底层还是队列的基本结构，
      只不过是在之上附加了其他功能。阻塞队列就是入队、出队操作可以阻塞。当队列为空时从对头取数时会阻塞，
      直到队列中有数据之后才返回；当队列为满时的插入操作就会阻塞，直到队列中有空闲位置时插入数据之后在返回。
      并发队列就是队列的操作多线程安全，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。

2.散列表/哈希表（Hash Table）
      
      散列思想：
      散列表用的是数组支持下标随机访问的数据特性，所以散列表其实就是一种数组的扩展，有数组演化而来，
      可以说，没有数组就没有散列表。
![image](https://github.com/chysh/data_struct/blob/master/images/hash.jpg)
      
      散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，
      然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，
      从对应的数组下标的位置取数据。
      
      散列函数：顾名思义是一个函数，记作 hash(key),key代表元素的键值，hash(key)的值就是经过散列函数计算得到的散列值。
      散列函数设计的基本要求：
            1.散列函数计算得到的散列值是非负整数。
            2.如果key1 == key2，那么hash(key1) == hash(key2).
            3.如果key1 != key2，那么hash(key1) != hash(key2).
            其中第三点，在真实的环境中，要找到一个不同的key得到不同的散列值的散列函数，几乎是不可能的，即使是业界著名的
            MD5，SHA，CRC等哈希算法也无法避免这种散列冲突，而且数组的空间有限，也会加大这种散列冲突的概率。
            
      散列冲突：
         再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，
         开放寻址法（open addressing）和链表法（chaining）。
         1.开放寻址法
            开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？
            一个比较简单的探测方法，线性探测（Linear Probing）：
            1.当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，
            依次往后查找，看是否有空闲位置，直到找到为止。
            如下图（黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。）
![image](https://github.com/chysh/data_struct/blob/master/images/xianxingtance.jpg)

            2.在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组
            中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数
            组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。如图：
![image](https://github.com/chysh/data_struct/blob/master/images/xianxingtance1.jpg)

            散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些
            特别。不能单纯地把要删除的元素设置为空。因为在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可
            以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数
            据，会被认定为不存在。这个问题如何解决呢？我们可以将删除的元素特殊标记为 deleted。当线性探测查找的时候，遇到
            标记为 deleted 的空间，并不是停下来，而是继续往下探测。
![image](https://github.com/chysh/data_struct/blob/master/images/xianxingtance2.jpg)

         2.链表法
            
 
